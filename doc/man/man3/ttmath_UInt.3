.TH "ttmath::UInt< value_size >" 3 "Fri Oct 9 2015" "My Project" \" -*- nroff -*-
.ad l
.nh
.SH NAME
ttmath::UInt< value_size > \- 
.PP
\fBUInt\fP implements a big integer value without a sign\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <ttmathuint\&.h>\fP
.PP
Inherited by \fBttmath::Int< value_size >\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "void \fBhash\fP (std::size_t &seed) const "
.br
.ti -1c
.RI "template<class ostream_type > void \fBPrintTable\fP (ostream_type &output) const "
.br
.ti -1c
.RI "template<class char_type , class ostream_type > void \fBPrintLog\fP (const char_type *msg, ostream_type &output) const "
.br
.ti -1c
.RI "template<class char_type , class ostream_type > void \fBPrintLog\fP (const char_type *msg, \fBuint\fP carry, ostream_type &output) const "
.br
.ti -1c
.RI "\fBuint\fP \fBSize\fP () const "
.br
.ti -1c
.RI "void \fBSetZero\fP ()"
.br
.ti -1c
.RI "void \fBSetOne\fP ()"
.br
.ti -1c
.RI "void \fBSetMax\fP ()"
.br
.ti -1c
.RI "void \fBSetMin\fP ()"
.br
.ti -1c
.RI "void \fBSetFromTable\fP (const \fBuint\fP *temp_table, \fBuint\fP temp_table_len)"
.br
.ti -1c
.RI "\fBuint\fP \fBAddOne\fP ()"
.br
.ti -1c
.RI "\fBuint\fP \fBSubOne\fP ()"
.br
.ti -1c
.RI "\fBuint\fP \fBRcl\fP (\fBuint\fP bits, \fBuint\fP c=0)"
.br
.ti -1c
.RI "\fBuint\fP \fBRcr\fP (\fBuint\fP bits, \fBuint\fP c=0)"
.br
.ti -1c
.RI "\fBuint\fP \fBCompensationToLeft\fP ()"
.br
.ti -1c
.RI "bool \fBFindLeadingBit\fP (\fBuint\fP &table_id, \fBuint\fP &index) const "
.br
.ti -1c
.RI "\fBuint\fP \fBGetBit\fP (\fBuint\fP bit_index) const "
.br
.ti -1c
.RI "\fBuint\fP \fBSetBit\fP (\fBuint\fP bit_index)"
.br
.ti -1c
.RI "void \fBBitAnd\fP (const \fBUInt\fP< value_size > &ss2)"
.br
.ti -1c
.RI "void \fBBitOr\fP (const \fBUInt\fP< value_size > &ss2)"
.br
.ti -1c
.RI "void \fBBitXor\fP (const \fBUInt\fP< value_size > &ss2)"
.br
.ti -1c
.RI "void \fBBitNot\fP ()"
.br
.ti -1c
.RI "void \fBBitNot2\fP ()"
.br
.ti -1c
.RI "\fBuint\fP \fBMulInt\fP (\fBuint\fP ss2)"
.br
.ti -1c
.RI "template<uint result_size> void \fBMulInt\fP (\fBuint\fP ss2, \fBUInt\fP< result_size > &result) const "
.br
.ti -1c
.RI "\fBuint\fP \fBMul\fP (const \fBUInt\fP< value_size > &ss2, \fBuint\fP algorithm=100)"
.br
.ti -1c
.RI "void \fBMulBig\fP (const \fBUInt\fP< value_size > &ss2, \fBUInt\fP< value_size *2 > &result, \fBuint\fP algorithm=100)"
.br
.ti -1c
.RI "\fBuint\fP \fBMul1\fP (const \fBUInt\fP< value_size > &ss2)"
.br
.ti -1c
.RI "void \fBMul1Big\fP (const \fBUInt\fP< value_size > &ss2_, \fBUInt\fP< value_size *2 > &result)"
.br
.ti -1c
.RI "\fBuint\fP \fBMul2\fP (const \fBUInt\fP< value_size > &ss2)"
.br
.ti -1c
.RI "void \fBMul2Big\fP (const \fBUInt\fP< value_size > &ss2, \fBUInt\fP< value_size *2 > &result)"
.br
.ti -1c
.RI "\fBuint\fP \fBMul3\fP (const \fBUInt\fP< value_size > &ss2)"
.br
.ti -1c
.RI "void \fBMul3Big\fP (const \fBUInt\fP< value_size > &ss2, \fBUInt\fP< value_size *2 > &result)"
.br
.ti -1c
.RI "\fBuint\fP \fBMulFastest\fP (const \fBUInt\fP< value_size > &ss2)"
.br
.ti -1c
.RI "void \fBMulFastestBig\fP (const \fBUInt\fP< value_size > &ss2, \fBUInt\fP< value_size *2 > &result)"
.br
.ti -1c
.RI "\fBuint\fP \fBDivInt\fP (\fBuint\fP divisor, \fBuint\fP *remainder=0)"
.br
.ti -1c
.RI "\fBuint\fP \fBDivInt\fP (\fBuint\fP divisor, \fBuint\fP &remainder)"
.br
.ti -1c
.RI "\fBuint\fP \fBDiv\fP (const \fBUInt\fP< value_size > &divisor, \fBUInt\fP< value_size > *remainder=0, \fBuint\fP algorithm=3)"
.br
.ti -1c
.RI "\fBuint\fP \fBDiv\fP (const \fBUInt\fP< value_size > &divisor, \fBUInt\fP< value_size > &remainder, \fBuint\fP algorithm=3)"
.br
.ti -1c
.RI "\fBuint\fP \fBDiv1\fP (const \fBUInt\fP< value_size > &divisor, \fBUInt\fP< value_size > *remainder=0)"
.br
.ti -1c
.RI "\fBuint\fP \fBDiv2\fP (const \fBUInt\fP< value_size > &divisor, \fBUInt\fP< value_size > *remainder=0)"
.br
.ti -1c
.RI "\fBuint\fP \fBDiv2\fP (const \fBUInt\fP< value_size > &divisor, \fBUInt\fP< value_size > &remainder)"
.br
.ti -1c
.RI "\fBuint\fP \fBDiv3\fP (const \fBUInt\fP< value_size > &v, \fBUInt\fP< value_size > *remainder=0)"
.br
.ti -1c
.RI "\fBuint\fP \fBPow\fP (\fBUInt\fP< value_size > pow)"
.br
.ti -1c
.RI "void \fBSqrt\fP ()"
.br
.ti -1c
.RI "void \fBClearFirstBits\fP (\fBuint\fP n)"
.br
.ti -1c
.RI "bool \fBIsTheHighestBitSet\fP () const "
.br
.ti -1c
.RI "bool \fBIsTheLowestBitSet\fP () const "
.br
.ti -1c
.RI "bool \fBIsZero\fP () const "
.br
.ti -1c
.RI "template<uint argument_size> \fBuint\fP \fBFromUInt\fP (const \fBUInt\fP< argument_size > &p)"
.br
.ti -1c
.RI "void \fBFromUInt\fP (\fBuint\fP value)"
.br
.ti -1c
.RI "template<uint argument_size> \fBUInt\fP< value_size > & \fBoperator=\fP (const \fBUInt\fP< argument_size > &p)"
.br
.ti -1c
.RI "\fBUInt\fP< value_size > & \fBoperator=\fP (const \fBUInt\fP< value_size > &p)"
.br
.ti -1c
.RI "\fBUInt\fP< value_size > & \fBoperator=\fP (\fBuint\fP i)"
.br
.ti -1c
.RI "\fBUInt\fP (\fBuint\fP i)"
.br
.ti -1c
.RI "\fBUInt\fP< value_size > & \fBoperator=\fP (sint i)"
.br
.ti -1c
.RI "\fBUInt\fP (sint i)"
.br
.ti -1c
.RI "\fBUInt\fP (const char *s)"
.br
.ti -1c
.RI "\fBUInt\fP (const wchar_t *s)"
.br
.ti -1c
.RI "\fBUInt\fP (const std::string &s)"
.br
.ti -1c
.RI "\fBUInt\fP (const std::wstring &s)"
.br
.ti -1c
.RI "\fBUInt\fP ()"
.br
.ti -1c
.RI "\fBUInt\fP (const \fBUInt\fP< value_size > &u)"
.br
.ti -1c
.RI "template<uint argument_size> \fBUInt\fP (const \fBUInt\fP< argument_size > &u)"
.br
.ti -1c
.RI "\fB~UInt\fP ()"
.br
.ti -1c
.RI "\fBuint\fP \fBToUInt\fP () const "
.br
.ti -1c
.RI "void \fBToString\fP (std::string &result, \fBuint\fP b=10) const "
.br
.ti -1c
.RI "void \fBToString\fP (std::wstring &result, \fBuint\fP b=10) const "
.br
.ti -1c
.RI "std::string \fBToString\fP (\fBuint\fP b=10) const "
.br
.ti -1c
.RI "std::wstring \fBToWString\fP (\fBuint\fP b=10) const "
.br
.ti -1c
.RI "\fBuint\fP \fBFromString\fP (const char *s, \fBuint\fP b=10, const char **after_source=0, bool *value_read=0)"
.br
.ti -1c
.RI "\fBuint\fP \fBFromString\fP (const wchar_t *s, \fBuint\fP b=10, const wchar_t **after_source=0, bool *value_read=0)"
.br
.ti -1c
.RI "\fBuint\fP \fBFromString\fP (const std::string &s, \fBuint\fP b=10)"
.br
.ti -1c
.RI "\fBuint\fP \fBFromString\fP (const std::wstring &s, \fBuint\fP b=10)"
.br
.ti -1c
.RI "\fBUInt\fP< value_size > & \fBoperator=\fP (const char *s)"
.br
.ti -1c
.RI "\fBUInt\fP< value_size > & \fBoperator=\fP (const wchar_t *s)"
.br
.ti -1c
.RI "\fBUInt\fP< value_size > & \fBoperator=\fP (const std::string &s)"
.br
.ti -1c
.RI "\fBUInt\fP< value_size > & \fBoperator=\fP (const std::wstring &s)"
.br
.ti -1c
.RI "bool \fBCmpSmaller\fP (const \fBUInt\fP< value_size > &l, sint index=-1) const "
.br
.ti -1c
.RI "bool \fBCmpBigger\fP (const \fBUInt\fP< value_size > &l, sint index=-1) const "
.br
.ti -1c
.RI "bool \fBCmpEqual\fP (const \fBUInt\fP< value_size > &l, sint index=-1) const "
.br
.ti -1c
.RI "bool \fBCmpSmallerEqual\fP (const \fBUInt\fP< value_size > &l, sint index=-1) const "
.br
.ti -1c
.RI "bool \fBCmpBiggerEqual\fP (const \fBUInt\fP< value_size > &l, sint index=-1) const "
.br
.ti -1c
.RI "bool \fBoperator<\fP (const \fBUInt\fP< value_size > &l) const "
.br
.ti -1c
.RI "bool \fBoperator>\fP (const \fBUInt\fP< value_size > &l) const "
.br
.ti -1c
.RI "bool \fBoperator==\fP (const \fBUInt\fP< value_size > &l) const "
.br
.ti -1c
.RI "bool \fBoperator!=\fP (const \fBUInt\fP< value_size > &l) const "
.br
.ti -1c
.RI "bool \fBoperator<=\fP (const \fBUInt\fP< value_size > &l) const "
.br
.ti -1c
.RI "bool \fBoperator>=\fP (const \fBUInt\fP< value_size > &l) const "
.br
.ti -1c
.RI "\fBUInt\fP< value_size > \fBoperator-\fP (const \fBUInt\fP< value_size > &p2) const "
.br
.ti -1c
.RI "\fBUInt\fP< value_size > & \fBoperator-=\fP (const \fBUInt\fP< value_size > &p2)"
.br
.ti -1c
.RI "\fBUInt\fP< value_size > \fBoperator+\fP (const \fBUInt\fP< value_size > &p2) const "
.br
.ti -1c
.RI "\fBUInt\fP< value_size > & \fBoperator+=\fP (const \fBUInt\fP< value_size > &p2)"
.br
.ti -1c
.RI "\fBUInt\fP< value_size > \fBoperator*\fP (const \fBUInt\fP< value_size > &p2) const "
.br
.ti -1c
.RI "\fBUInt\fP< value_size > & \fBoperator*=\fP (const \fBUInt\fP< value_size > &p2)"
.br
.ti -1c
.RI "\fBUInt\fP< value_size > \fBoperator/\fP (const \fBUInt\fP< value_size > &p2) const "
.br
.ti -1c
.RI "\fBUInt\fP< value_size > & \fBoperator/=\fP (const \fBUInt\fP< value_size > &p2)"
.br
.ti -1c
.RI "\fBUInt\fP< value_size > \fBoperator%\fP (const \fBUInt\fP< value_size > &p2) const "
.br
.ti -1c
.RI "\fBUInt\fP< value_size > & \fBoperator%=\fP (const \fBUInt\fP< value_size > &p2)"
.br
.ti -1c
.RI "\fBUInt\fP< value_size > & \fBoperator++\fP ()"
.br
.ti -1c
.RI "\fBUInt\fP< value_size > \fBoperator++\fP (int)"
.br
.ti -1c
.RI "\fBUInt\fP< value_size > & \fBoperator--\fP ()"
.br
.ti -1c
.RI "\fBUInt\fP< value_size > \fBoperator--\fP (int)"
.br
.ti -1c
.RI "\fBUInt\fP< value_size > \fBoperator>>\fP (int move)"
.br
.ti -1c
.RI "\fBUInt\fP< value_size > & \fBoperator>>=\fP (int move)"
.br
.ti -1c
.RI "\fBUInt\fP< value_size > \fBoperator<<\fP (int move)"
.br
.ti -1c
.RI "\fBUInt\fP< value_size > & \fBoperator<<=\fP (int move)"
.br
.ti -1c
.RI "\fBuint\fP \fBAdd\fP (const \fBUInt\fP< value_size > &ss2, \fBuint\fP c=0)"
.br
.ti -1c
.RI "\fBuint\fP \fBAddInt\fP (\fBuint\fP value, \fBuint\fP index=0)"
.br
.ti -1c
.RI "\fBuint\fP \fBAddTwoInts\fP (\fBuint\fP x2, \fBuint\fP x1, \fBuint\fP index)"
.br
.ti -1c
.RI "\fBuint\fP \fBSub\fP (const \fBUInt\fP< value_size > &ss2, \fBuint\fP c=0)"
.br
.ti -1c
.RI "\fBuint\fP \fBSubInt\fP (\fBuint\fP value, \fBuint\fP index=0)"
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "template<class char_type , class ostream_type > static void \fBPrintVectorLog\fP (const char_type *msg, ostream_type &output, const \fBuint\fP *vector, \fBuint\fP vector_len)"
.br
.ti -1c
.RI "template<class char_type , class ostream_type > static void \fBPrintVectorLog\fP (const char_type *msg, \fBuint\fP carry, ostream_type &output, const \fBuint\fP *vector, \fBuint\fP vector_len)"
.br
.ti -1c
.RI "static \fBuint\fP \fBAddTwoWords\fP (\fBuint\fP a, \fBuint\fP b, \fBuint\fP carry, \fBuint\fP *result)"
.br
.ti -1c
.RI "static \fBuint\fP \fBSubTwoWords\fP (\fBuint\fP a, \fBuint\fP b, \fBuint\fP carry, \fBuint\fP *result)"
.br
.ti -1c
.RI "static const char * \fBLibTypeStr\fP ()"
.br
.ti -1c
.RI "static \fBLibTypeCode\fP \fBLibType\fP ()"
.br
.ti -1c
.RI "static \fBuint\fP \fBAddVector\fP (const \fBuint\fP *ss1, const \fBuint\fP *ss2, \fBuint\fP ss1_size, \fBuint\fP ss2_size, \fBuint\fP *result)"
.br
.ti -1c
.RI "static \fBuint\fP \fBSubVector\fP (const \fBuint\fP *ss1, const \fBuint\fP *ss2, \fBuint\fP ss1_size, \fBuint\fP ss2_size, \fBuint\fP *result)"
.br
.ti -1c
.RI "static sint \fBFindLeadingBitInWord\fP (\fBuint\fP x)"
.br
.ti -1c
.RI "static \fBuint\fP \fBSetBitInWord\fP (\fBuint\fP &value, \fBuint\fP bit)"
.br
.ti -1c
.RI "static void \fBMulTwoWords\fP (\fBuint\fP a, \fBuint\fP b, \fBuint\fP *result_high, \fBuint\fP *result_low)"
.br
.ti -1c
.RI "static void \fBDivTwoWords\fP (\fBuint\fP a, \fBuint\fP b, \fBuint\fP c, \fBuint\fP *r, \fBuint\fP *rest)"
.br
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "\fBuint\fP \fBtable\fP [value_size]"
.br
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "std::ostream & \fBoperator<<\fP (std::ostream &s, const \fBUInt\fP< value_size > &l)"
.br
.ti -1c
.RI "std::wostream & \fBoperator<<\fP (std::wostream &s, const \fBUInt\fP< value_size > &l)"
.br
.ti -1c
.RI "std::istream & \fBoperator>>\fP (std::istream &s, \fBUInt\fP< value_size > &l)"
.br
.ti -1c
.RI "std::wistream & \fBoperator>>\fP (std::wistream &s, \fBUInt\fP< value_size > &l)"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<uint value_size>class ttmath::UInt< value_size >"
\fBUInt\fP implements a big integer value without a sign\&. 

value_size - how many bytes specify our value on 32bit platforms: value_size=1 -> 4 bytes -> 32 bits on 64bit platforms: value_size=1 -> 8 bytes -> 64 bits value_size = 1,2,3,4,5,6\&.\&.\&.\&. 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<uint value_size> \fBttmath::UInt\fP< value_size >::\fBUInt\fP (\fBuint\fPi)\fC [inline]\fP"
a constructor for converting the uint to this class 
.PP
References ttmath::UInt< value_size >::FromUInt()\&.
.SS "template<uint value_size> \fBttmath::UInt\fP< value_size >::\fBUInt\fP (sinti)\fC [inline]\fP"
a constructor for converting the sint to this class
.PP
look at the description of \fBUInt::operator=(sint)\fP 
.PP
References ttmath::UInt< value_size >::FromUInt()\&.
.SS "template<uint value_size> \fBttmath::UInt\fP< value_size >::\fBUInt\fP (const char *s)\fC [inline]\fP"
a constructor for converting a string to this class (with the base=10) 
.PP
References ttmath::UInt< value_size >::FromString()\&.
.SS "template<uint value_size> \fBttmath::UInt\fP< value_size >::\fBUInt\fP (const wchar_t *s)\fC [inline]\fP"
a constructor for converting a string to this class (with the base=10) 
.PP
References ttmath::UInt< value_size >::FromString()\&.
.SS "template<uint value_size> \fBttmath::UInt\fP< value_size >::\fBUInt\fP (const std::string &s)\fC [inline]\fP"
a constructor for converting a string to this class (with the base=10) 
.PP
References ttmath::UInt< value_size >::FromString()\&.
.SS "template<uint value_size> \fBttmath::UInt\fP< value_size >::\fBUInt\fP (const std::wstring &s)\fC [inline]\fP"
a constructor for converting a string to this class (with the base=10) 
.PP
References ttmath::UInt< value_size >::FromString()\&.
.SS "template<uint value_size> \fBttmath::UInt\fP< value_size >::\fBUInt\fP ()\fC [inline]\fP"
a default constructor
.PP
we don't clear the table 
.SS "template<uint value_size> \fBttmath::UInt\fP< value_size >::\fBUInt\fP (const \fBUInt\fP< value_size > &u)\fC [inline]\fP"
a copy constructor 
.PP
References ttmath::UInt< value_size >::table\&.
.SS "template<uint value_size> template<uint argument_size> \fBttmath::UInt\fP< value_size >::\fBUInt\fP (const \fBUInt\fP< argument_size > &u)\fC [inline]\fP"
a template for producting constructors for copying from another types 
.PP
References ttmath::UInt< value_size >::FromUInt()\&.
.SS "template<uint value_size> \fBttmath::UInt\fP< value_size >::~\fBUInt\fP ()\fC [inline]\fP"
a destructor 
.SH "Member Function Documentation"
.PP 
.SS "template<uint value_size> \fBuint\fP \fBttmath::UInt\fP< value_size >::AddOne ()\fC [inline]\fP"
basic mathematic functions
.PP
this method adds one to the existing value 
.PP
Referenced by ttmath::Int< value_size >::AddOne(), and ttmath::UInt< value_size >::operator++()\&.
.SS "template<uint value_size> void \fBttmath::UInt\fP< value_size >::BitAnd (const \fBUInt\fP< value_size > &ss2)\fC [inline]\fP"
this method performs a bitwise operation AND 
.PP
References ttmath::UInt< value_size >::table\&.
.SS "template<uint value_size> void \fBttmath::UInt\fP< value_size >::BitNot ()\fC [inline]\fP"
this method performs a bitwise operation NOT 
.PP
References ttmath::UInt< value_size >::table\&.
.SS "template<uint value_size> void \fBttmath::UInt\fP< value_size >::BitNot2 ()\fC [inline]\fP"
this method performs a bitwise operation NOT but only on the range of <0, leading_bit>
.PP
for example: BitNot2(8) = BitNot2( 1000(bin) ) = 111(bin) = 7 
.PP
References ttmath::UInt< value_size >::FindLeadingBit(), ttmath::UInt< value_size >::table, TTMATH_BITS_PER_UINT, and TTMATH_UINT_MAX_VALUE\&.
.SS "template<uint value_size> void \fBttmath::UInt\fP< value_size >::BitOr (const \fBUInt\fP< value_size > &ss2)\fC [inline]\fP"
this method performs a bitwise operation OR 
.PP
References ttmath::UInt< value_size >::table\&.
.SS "template<uint value_size> void \fBttmath::UInt\fP< value_size >::BitXor (const \fBUInt\fP< value_size > &ss2)\fC [inline]\fP"
this method performs a bitwise operation XOR 
.PP
References ttmath::UInt< value_size >::table\&.
.SS "template<uint value_size> void \fBttmath::UInt\fP< value_size >::ClearFirstBits (\fBuint\fPn)\fC [inline]\fP"
this method sets n first bits to value zero
.PP
For example: let n=2 then if there's a value 111 (bin) there'll be '100' (bin) 
.PP
References ttmath::UInt< value_size >::SetZero(), ttmath::UInt< value_size >::table, TTMATH_BITS_PER_UINT, and TTMATH_UINT_MAX_VALUE\&.
.SS "template<uint value_size> bool \fBttmath::UInt\fP< value_size >::CmpBigger (const \fBUInt\fP< value_size > &l, sintindex = \fC-1\fP) const\fC [inline]\fP"
this method returns true if 'this' is bigger than 'l'
.PP
'index' is an index of the first word from will be the comparison performed (note: we start the comparison from back - from the last word, when index is -1 /default/ it is automatically set into the last word)
.PP
I introduced it for some kind of optimization made in the second division algorithm (Div2) 
.PP
References ttmath::UInt< value_size >::table\&.
.SS "template<uint value_size> bool \fBttmath::UInt\fP< value_size >::CmpBiggerEqual (const \fBUInt\fP< value_size > &l, sintindex = \fC-1\fP) const\fC [inline]\fP"
this method returns true if 'this' is bigger than or equal 'l'
.PP
'index' is an index of the first word from will be the comparison performed (note: we start the comparison from back - from the last word, when index is -1 /default/ it is automatically set into the last word) 
.PP
References ttmath::UInt< value_size >::table\&.
.PP
Referenced by ttmath::UInt< value_size >::Div2()\&.
.SS "template<uint value_size> bool \fBttmath::UInt\fP< value_size >::CmpEqual (const \fBUInt\fP< value_size > &l, sintindex = \fC-1\fP) const\fC [inline]\fP"
this method returns true if 'this' is equal 'l'
.PP
'index' is an index of the first word from will be the comparison performed (note: we start the comparison from back - from the last word, when index is -1 /default/ it is automatically set into the last word) 
.PP
References ttmath::UInt< value_size >::table\&.
.SS "template<uint value_size> bool \fBttmath::UInt\fP< value_size >::CmpSmaller (const \fBUInt\fP< value_size > &l, sintindex = \fC-1\fP) const\fC [inline]\fP"
methods for comparing
.PP
this method returns true if 'this' is smaller than 'l'
.PP
'index' is an index of the first word from will be the comparison performed (note: we start the comparison from back - from the last word, when index is -1 /default/ it is automatically set into the last word) I introduced it for some kind of optimization made in the second division algorithm (Div2) 
.PP
References ttmath::UInt< value_size >::table\&.
.SS "template<uint value_size> bool \fBttmath::UInt\fP< value_size >::CmpSmallerEqual (const \fBUInt\fP< value_size > &l, sintindex = \fC-1\fP) const\fC [inline]\fP"
this method returns true if 'this' is smaller than or equal 'l'
.PP
'index' is an index of the first word from will be the comparison performed (note: we start the comparison from back - from the last word, when index is -1 /default/ it is automatically set into the last word) 
.PP
References ttmath::UInt< value_size >::table\&.
.SS "template<uint value_size> \fBuint\fP \fBttmath::UInt\fP< value_size >::CompensationToLeft ()\fC [inline]\fP"
this method moves all bits into the left side (it returns value how many bits have been moved) 
.PP
References ttmath::UInt< value_size >::Rcl(), ttmath::UInt< value_size >::table, and TTMATH_BITS_PER_UINT\&.
.SS "template<uint value_size> \fBuint\fP \fBttmath::UInt\fP< value_size >::Div (const \fBUInt\fP< value_size > &divisor, \fBUInt\fP< value_size > *remainder = \fC0\fP, \fBuint\fPalgorithm = \fC3\fP)\fC [inline]\fP"
division this = this / ss2
.PP
return values: 0 - ok 1 - division by zero 'this' will be the quotient 'remainder' - remainder 
.PP
References ttmath::UInt< value_size >::Div1(), ttmath::UInt< value_size >::Div2(), and ttmath::UInt< value_size >::Div3()\&.
.PP
Referenced by ttmath::Int< value_size >::Div()\&.
.SS "template<uint value_size> \fBuint\fP \fBttmath::UInt\fP< value_size >::Div1 (const \fBUInt\fP< value_size > &divisor, \fBUInt\fP< value_size > *remainder = \fC0\fP)\fC [inline]\fP"
the first division algorithm radix 2 
.PP
Referenced by ttmath::UInt< value_size >::Div()\&.
.SS "template<uint value_size> \fBuint\fP \fBttmath::UInt\fP< value_size >::Div2 (const \fBUInt\fP< value_size > &divisor, \fBUInt\fP< value_size > *remainder = \fC0\fP)\fC [inline]\fP"
the second division algorithm
.PP
return values: 0 - ok 1 - division by zero 
.PP
References ttmath::UInt< value_size >::CmpBiggerEqual(), ttmath::UInt< value_size >::SetBit(), ttmath::UInt< value_size >::SetZero(), and TTMATH_REFERENCE_ASSERT\&.
.PP
Referenced by ttmath::UInt< value_size >::Div()\&.
.SS "template<uint value_size> \fBuint\fP \fBttmath::UInt\fP< value_size >::Div3 (const \fBUInt\fP< value_size > &v, \fBUInt\fP< value_size > *remainder = \fC0\fP)\fC [inline]\fP"
the third division algorithm
.PP
this algorithm is described in the following book: 'The art of computer programming 2' (4\&.3\&.1 page 272) Donald E\&. Knuth 
.PP
References ttmath::UInt< value_size >::DivInt(), and TTMATH_REFERENCE_ASSERT\&.
.PP
Referenced by ttmath::UInt< value_size >::Div()\&.
.SS "template<uint value_size> \fBuint\fP \fBttmath::UInt\fP< value_size >::DivInt (\fBuint\fPdivisor, \fBuint\fP *remainder = \fC0\fP)\fC [inline]\fP"
Division
.PP
division by one unsigned word
.PP
returns 1 when divisor is zero 
.PP
References ttmath::UInt< value_size >::SetZero(), and ttmath::UInt< value_size >::table\&.
.PP
Referenced by ttmath::UInt< value_size >::Div3(), and ttmath::Int< value_size >::DivInt()\&.
.SS "template<uint value_size> bool \fBttmath::UInt\fP< value_size >::FindLeadingBit (\fBuint\fP &table_id, \fBuint\fP &index) const\fC [inline]\fP"
this method looks for the highest set bit
.PP
result: if 'this' is not zero: return value - true 'table_id' - the index of a word <0\&.\&.value_size-1> 'index' - the index of this set bit in the word <0\&.\&.31>
.PP
if 'this' is zero: return value - false both 'table_id' and 'index' are zero 
.PP
References ttmath::UInt< value_size >::table\&.
.PP
Referenced by ttmath::UInt< value_size >::BitNot2()\&.
.SS "template<uint value_size> \fBuint\fP \fBttmath::UInt\fP< value_size >::FromString (const char *s, \fBuint\fPb = \fC10\fP, const char **after_source = \fC0\fP, bool *value_read = \fC0\fP)\fC [inline]\fP"
this method converts a string into its value it returns carry=1 if the value will be too big or an incorrect base 'b' is given
.PP
string is ended with a non-digit value, for example: '12' will be translated to 12 as well as: '12foo' will be translated to 12 too
.PP
existing first white characters will be ommited
.PP
if the value from s is too large the rest digits will be skipped
.PP
after_source (if exists) is pointing at the end of the parsed string
.PP
value_read (if exists) tells whether something has actually been read (at least one digit) 
.PP
Referenced by ttmath::UInt< value_size >::FromString(), ttmath::UInt< value_size >::operator=(), and ttmath::UInt< value_size >::UInt()\&.
.SS "template<uint value_size> \fBuint\fP \fBttmath::UInt\fP< value_size >::FromString (const wchar_t *s, \fBuint\fPb = \fC10\fP, const wchar_t **after_source = \fC0\fP, bool *value_read = \fC0\fP)\fC [inline]\fP"
this method converts a string into its value 
.SS "template<uint value_size> \fBuint\fP \fBttmath::UInt\fP< value_size >::FromString (const std::string &s, \fBuint\fPb = \fC10\fP)\fC [inline]\fP"
this method converts a string into its value
.PP
(it returns carry=1 if the value will be too big or an incorrect base 'b' is given) 
.PP
References ttmath::UInt< value_size >::FromString()\&.
.SS "template<uint value_size> \fBuint\fP \fBttmath::UInt\fP< value_size >::FromString (const std::wstring &s, \fBuint\fPb = \fC10\fP)\fC [inline]\fP"
this method converts a string into its value
.PP
(it returns carry=1 if the value will be too big or an incorrect base 'b' is given) 
.PP
References ttmath::UInt< value_size >::FromString()\&.
.SS "template<uint value_size> template<uint argument_size> \fBuint\fP \fBttmath::UInt\fP< value_size >::FromUInt (const \fBUInt\fP< argument_size > &p)\fC [inline]\fP"
conversion methods
.PP
this method converts an UInt<another_size> type to this class
.PP
this operation has mainly sense if the value from p is equal or smaller than that one which is returned from \fBUInt<value_size>::SetMax()\fP
.PP
it returns a carry if the value 'p' is too big 
.PP
References ttmath::UInt< value_size >::table\&.
.PP
Referenced by ttmath::UInt< value_size >::operator=(), and ttmath::UInt< value_size >::UInt()\&.
.SS "template<uint value_size> void \fBttmath::UInt\fP< value_size >::FromUInt (\fBuint\fPvalue)\fC [inline]\fP"
this method converts the uint type to this class 
.SS "template<uint value_size> \fBuint\fP \fBttmath::UInt\fP< value_size >::GetBit (\fBuint\fPbit_index) const\fC [inline]\fP"
setting the 'bit_index' bit
.PP
bit_index bigger or equal zero 
.PP
References ttmath::UInt< value_size >::table, and TTMATH_BITS_PER_UINT\&.
.SS "template<uint value_size> bool \fBttmath::UInt\fP< value_size >::IsTheHighestBitSet () const\fC [inline]\fP"
this method returns true if the highest bit of the value is set 
.PP
Referenced by ttmath::Int< value_size >::IsSign()\&.
.SS "template<uint value_size> bool \fBttmath::UInt\fP< value_size >::IsTheLowestBitSet () const\fC [inline]\fP"
this method returns true if the lowest bit of the value is set 
.SS "template<uint value_size> bool \fBttmath::UInt\fP< value_size >::IsZero () const\fC [inline]\fP"
this method returns true if the value is equal zero 
.PP
Referenced by ttmath::UInt< value_size >::Pow(), and ttmath::UInt< value_size >::Sqrt()\&.
.SS "template<uint value_size> \fBuint\fP \fBttmath::UInt\fP< value_size >::Mul (const \fBUInt\fP< value_size > &ss2, \fBuint\fPalgorithm = \fC100\fP)\fC [inline]\fP"
the multiplication 'this' = 'this' * ss2
.PP
algorithm: 100 - means automatically choose the fastest algorithm 
.PP
References ttmath::UInt< value_size >::Mul1(), ttmath::UInt< value_size >::Mul2(), ttmath::UInt< value_size >::Mul3(), and ttmath::UInt< value_size >::MulFastest()\&.
.PP
Referenced by ttmath::UInt< value_size >::Pow()\&.
.SS "template<uint value_size> \fBuint\fP \fBttmath::UInt\fP< value_size >::Mul1 (const \fBUInt\fP< value_size > &ss2)\fC [inline]\fP"
the first version of the multiplication algorithm
.PP
multiplication: this = this * ss2
.PP
it returns carry if it has been 
.PP
References ttmath::UInt< value_size >::Rcl(), ttmath::UInt< value_size >::SetZero(), TTMATH_BITS_PER_UINT, and TTMATH_REFERENCE_ASSERT\&.
.PP
Referenced by ttmath::UInt< value_size >::Mul(), and ttmath::UInt< value_size >::Mul1Big()\&.
.SS "template<uint value_size> void \fBttmath::UInt\fP< value_size >::Mul1Big (const \fBUInt\fP< value_size > &ss2_, \fBUInt\fP< value_size *2 > &result)\fC [inline]\fP"
multiplication: result = this * ss2
.PP
result is twice bigger than 'this' and 'ss2' this method never returns carry 
.PP
References ttmath::UInt< value_size >::Mul1(), and ttmath::UInt< value_size >::table\&.
.PP
Referenced by ttmath::UInt< value_size >::MulBig()\&.
.SS "template<uint value_size> \fBuint\fP \fBttmath::UInt\fP< value_size >::Mul2 (const \fBUInt\fP< value_size > &ss2)\fC [inline]\fP"
the second version of the multiplication algorithm
.PP
this algorithm is similar to the 'schoolbook method' which is done by hand
.PP
multiplication: this = this * ss2
.PP
it returns carry if it has been 
.PP
References ttmath::UInt< value_size >::Mul2Big(), and ttmath::UInt< value_size >::table\&.
.PP
Referenced by ttmath::UInt< value_size >::Mul()\&.
.SS "template<uint value_size> void \fBttmath::UInt\fP< value_size >::Mul2Big (const \fBUInt\fP< value_size > &ss2, \fBUInt\fP< value_size *2 > &result)\fC [inline]\fP"
multiplication: result = this * ss2
.PP
result is twice bigger than this and ss2 this method never returns carry 
.PP
References ttmath::UInt< value_size >::table\&.
.PP
Referenced by ttmath::UInt< value_size >::Mul2(), ttmath::UInt< value_size >::MulBig(), and ttmath::UInt< value_size >::MulFastestBig()\&.
.SS "template<uint value_size> \fBuint\fP \fBttmath::UInt\fP< value_size >::Mul3 (const \fBUInt\fP< value_size > &ss2)\fC [inline]\fP"
multiplication: this = this * ss2
.PP
This is Karatsuba Multiplication algorithm, we're using it when value_size is greater than or equal to TTMATH_USE_KARATSUBA_MULTIPLICATION_FROM_SIZE macro (defined in \fBttmathuint\&.h\fP)\&. If value_size is smaller then we're using \fBMul2Big()\fP instead\&.
.PP
Karatsuba multiplication: Assume we have: this = x = x1*B^m + x0 ss2 = y = y1*B^m + y0 where x0 and y0 are less than B^m the product from multiplication we can show as: x*y = (x1*B^m + x0)(y1*B^m + y0) = z2*B^(2m) + z1*B^m + z0 where z2 = x1*y1 z1 = x1*y0 + x0*y1 z0 = x0*y0 this is standard schoolbook algorithm with O(n^2), Karatsuba observed that z1 can be given in other form: z1 = (x1 + x0)*(y1 + y0) - z2 - z0 / z1 = (x1*y1 + x1*y0 + x0*y1 + x0*y0) - x1*y1 - x0*y0 = x1*y0 + x0*y1 / and to calculate the multiplication we need only three multiplications (with some additions and subtractions)
.PP
Our objects 'this' and 'ss2' we divide into two parts and by using recurrence we calculate the multiplication\&. Karatsuba multiplication has O( n^(ln(3)/ln(2)) ) 
.PP
References ttmath::UInt< value_size >::Mul3Big(), and ttmath::UInt< value_size >::table\&.
.PP
Referenced by ttmath::UInt< value_size >::Mul()\&.
.SS "template<uint value_size> void \fBttmath::UInt\fP< value_size >::Mul3Big (const \fBUInt\fP< value_size > &ss2, \fBUInt\fP< value_size *2 > &result)\fC [inline]\fP"
multiplication: result = this * ss2
.PP
result is twice bigger than this and ss2, this method never returns carry, (Karatsuba multiplication) 
.PP
References ttmath::UInt< value_size >::table\&.
.PP
Referenced by ttmath::UInt< value_size >::Mul3(), ttmath::UInt< value_size >::MulBig(), and ttmath::UInt< value_size >::MulFastestBig()\&.
.SS "template<uint value_size> void \fBttmath::UInt\fP< value_size >::MulBig (const \fBUInt\fP< value_size > &ss2, \fBUInt\fP< value_size *2 > &result, \fBuint\fPalgorithm = \fC100\fP)\fC [inline]\fP"
the multiplication 'result' = 'this' * ss2
.PP
since the 'result' is twice bigger than 'this' and 'ss2' this method never returns a carry
.PP
algorithm: 100 - means automatically choose the fastest algorithm 
.PP
References ttmath::UInt< value_size >::Mul1Big(), ttmath::UInt< value_size >::Mul2Big(), ttmath::UInt< value_size >::Mul3Big(), and ttmath::UInt< value_size >::MulFastestBig()\&.
.SS "template<uint value_size> \fBuint\fP \fBttmath::UInt\fP< value_size >::MulFastest (const \fBUInt\fP< value_size > &ss2)\fC [inline]\fP"
multiplication this = this * ss2 
.PP
References ttmath::UInt< value_size >::MulFastestBig(), and ttmath::UInt< value_size >::table\&.
.PP
Referenced by ttmath::UInt< value_size >::Mul()\&.
.SS "template<uint value_size> void \fBttmath::UInt\fP< value_size >::MulFastestBig (const \fBUInt\fP< value_size > &ss2, \fBUInt\fP< value_size *2 > &result)\fC [inline]\fP"
multiplication result = this * ss2
.PP
this method is trying to select the fastest algorithm (in the future this method can be improved) 
.PP
References ttmath::UInt< value_size >::Mul2Big(), ttmath::UInt< value_size >::Mul3Big(), ttmath::UInt< value_size >::SetZero(), ttmath::UInt< value_size >::table, and TTMATH_USE_KARATSUBA_MULTIPLICATION_FROM_SIZE\&.
.PP
Referenced by ttmath::UInt< value_size >::MulBig(), and ttmath::UInt< value_size >::MulFastest()\&.
.SS "template<uint value_size> \fBuint\fP \fBttmath::UInt\fP< value_size >::MulInt (\fBuint\fPss2)\fC [inline]\fP"
Multiplication
.PP
multiplication: this = this * ss2
.PP
it can return a carry 
.PP
References ttmath::UInt< value_size >::SetZero(), and ttmath::UInt< value_size >::table\&.
.SS "template<uint value_size> template<uint result_size> void \fBttmath::UInt\fP< value_size >::MulInt (\fBuint\fPss2, \fBUInt\fP< result_size > &result) const\fC [inline]\fP"
multiplication: result = this * ss2
.PP
we're using this method only when result_size is greater than value_size if so there will not be a carry 
.PP
References ttmath::UInt< value_size >::SetZero(), and ttmath::UInt< value_size >::table\&.
.SS "template<uint value_size> \fBUInt\fP<value_size>& \fBttmath::UInt\fP< value_size >::operator++ ()\fC [inline]\fP"
Prefix operator e\&.g ++variable 
.PP
References ttmath::UInt< value_size >::AddOne()\&.
.SS "template<uint value_size> \fBUInt\fP<value_size> \fBttmath::UInt\fP< value_size >::operator++ (int)\fC [inline]\fP"
Postfix operator e\&.g variable++ 
.PP
References ttmath::UInt< value_size >::AddOne()\&.
.SS "template<uint value_size> \fBUInt\fP<value_size> \fBttmath::UInt\fP< value_size >::operator- (const \fBUInt\fP< value_size > &p2) const\fC [inline]\fP"
standard mathematical operators 
.SS "template<uint value_size> template<uint argument_size> \fBUInt\fP<value_size>& \fBttmath::UInt\fP< value_size >::operator= (const \fBUInt\fP< argument_size > &p)\fC [inline]\fP"
this operator converts an UInt<another_size> type to this class
.PP
it doesn't return a carry 
.PP
References ttmath::UInt< value_size >::FromUInt()\&.
.SS "template<uint value_size> \fBUInt\fP<value_size>& \fBttmath::UInt\fP< value_size >::operator= (const \fBUInt\fP< value_size > &p)\fC [inline]\fP"
the assignment operator 
.PP
References ttmath::UInt< value_size >::table\&.
.SS "template<uint value_size> \fBUInt\fP<value_size>& \fBttmath::UInt\fP< value_size >::operator= (\fBuint\fPi)\fC [inline]\fP"
this method converts the uint type to this class 
.PP
References ttmath::UInt< value_size >::FromUInt()\&.
.SS "template<uint value_size> \fBUInt\fP<value_size>& \fBttmath::UInt\fP< value_size >::operator= (sinti)\fC [inline]\fP"
this method converts the sint type to this class
.PP
we provide operator(sint) and the constructor(sint) in order to allow the programmer do that: UInt<\&.\&.> type = 10;
.PP
above '10' constant has the int type (signed int), if we don't give such operators and constructors the compiler will not compile the program, because it has to make a conversion and doesn't know into which type (the \fBUInt\fP class has \fBoperator=(const char*)\fP, \fBoperator=(uint)\fP etc\&.) 
.PP
References ttmath::UInt< value_size >::FromUInt()\&.
.SS "template<uint value_size> \fBUInt\fP<value_size>& \fBttmath::UInt\fP< value_size >::operator= (const char *s)\fC [inline]\fP"
this operator converts a string into its value (with base = 10) 
.PP
References ttmath::UInt< value_size >::FromString()\&.
.SS "template<uint value_size> \fBUInt\fP<value_size>& \fBttmath::UInt\fP< value_size >::operator= (const wchar_t *s)\fC [inline]\fP"
this operator converts a string into its value (with base = 10) 
.PP
References ttmath::UInt< value_size >::FromString()\&.
.SS "template<uint value_size> \fBUInt\fP<value_size>& \fBttmath::UInt\fP< value_size >::operator= (const std::string &s)\fC [inline]\fP"
this operator converts a string into its value (with base = 10) 
.PP
References ttmath::UInt< value_size >::FromString()\&.
.SS "template<uint value_size> \fBUInt\fP<value_size>& \fBttmath::UInt\fP< value_size >::operator= (const std::wstring &s)\fC [inline]\fP"
this operator converts a string into its value (with base = 10) 
.PP
References ttmath::UInt< value_size >::FromString()\&.
.SS "template<uint value_size> \fBuint\fP \fBttmath::UInt\fP< value_size >::Pow (\fBUInt\fP< value_size >pow)\fC [inline]\fP"
power this = this ^ pow binary algorithm (r-to-l)
.PP
return values: 0 - ok 1 - carry 2 - incorrect argument (0^0) 
.PP
References ttmath::UInt< value_size >::IsZero(), ttmath::UInt< value_size >::Mul(), ttmath::UInt< value_size >::SetOne(), and ttmath::UInt< value_size >::table\&.
.SS "template<uint value_size> template<class char_type , class ostream_type > void \fBttmath::UInt\fP< value_size >::PrintLog (const char_type *msg, ostream_type &output) const\fC [inline]\fP"
this method is used when macro TTMATH_DEBUG_LOG is defined 
.PP
References ttmath::UInt< value_size >::PrintVectorLog(), and ttmath::UInt< value_size >::table\&.
.SS "template<uint value_size> template<class char_type , class ostream_type > void \fBttmath::UInt\fP< value_size >::PrintLog (const char_type *msg, \fBuint\fPcarry, ostream_type &output) const\fC [inline]\fP"
this method is used when macro TTMATH_DEBUG_LOG is defined 
.PP
References ttmath::UInt< value_size >::PrintVectorLog(), and ttmath::UInt< value_size >::table\&.
.SS "template<uint value_size> template<class ostream_type > void \fBttmath::UInt\fP< value_size >::PrintTable (ostream_type &output) const\fC [inline]\fP"
some methods used for debugging purposes
.PP
this method is only for debugging purposes or when we want to make a table of a variable (constant) in ttmathbig\&.h
.PP
it prints the table in a nice form of several columns 
.PP
References ttmath::UInt< value_size >::table\&.
.SS "template<uint value_size> template<class char_type , class ostream_type > static void \fBttmath::UInt\fP< value_size >::PrintVectorLog (const char_type *msg, ostream_type &output, const \fBuint\fP *vector, \fBuint\fPvector_len)\fC [inline]\fP, \fC [static]\fP"
this method is used when macro TTMATH_DEBUG_LOG is defined 
.PP
Referenced by ttmath::UInt< value_size >::PrintLog(), and ttmath::UInt< value_size >::PrintVectorLog()\&.
.SS "template<uint value_size> template<class char_type , class ostream_type > static void \fBttmath::UInt\fP< value_size >::PrintVectorLog (const char_type *msg, \fBuint\fPcarry, ostream_type &output, const \fBuint\fP *vector, \fBuint\fPvector_len)\fC [inline]\fP, \fC [static]\fP"
this method is used when macro TTMATH_DEBUG_LOG is defined 
.PP
References ttmath::UInt< value_size >::PrintVectorLog()\&.
.SS "template<uint value_size> \fBuint\fP \fBttmath::UInt\fP< value_size >::Rcl (\fBuint\fPbits, \fBuint\fPc = \fC0\fP)\fC [inline]\fP"
moving all bits into the left side 'bits' times return value <- this <- C
.PP
bits is from a range of <0, man * TTMATH_BITS_PER_UINT> or it can be even bigger then all bits will be set to 'c'
.PP
the value c will be set into the lowest bits and the method returns state of the last moved bit 
.PP
References TTMATH_BITS_PER_UINT\&.
.PP
Referenced by ttmath::UInt< value_size >::CompensationToLeft(), and ttmath::UInt< value_size >::Mul1()\&.
.SS "template<uint value_size> \fBuint\fP \fBttmath::UInt\fP< value_size >::Rcr (\fBuint\fPbits, \fBuint\fPc = \fC0\fP)\fC [inline]\fP"
moving all bits into the right side 'bits' times c -> this -> return value
.PP
bits is from a range of <0, man * TTMATH_BITS_PER_UINT> or it can be even bigger then all bits will be set to 'c'
.PP
the value c will be set into the highest bits and the method returns state of the last moved bit 
.PP
References TTMATH_BITS_PER_UINT\&.
.PP
Referenced by ttmath::UInt< value_size >::Sqrt()\&.
.SS "template<uint value_size> \fBuint\fP \fBttmath::UInt\fP< value_size >::SetBit (\fBuint\fPbit_index)\fC [inline]\fP"
setting the 'bit_index' bit and returning the last state of the bit
.PP
bit_index bigger or equal zero 
.PP
References ttmath::UInt< value_size >::table, and TTMATH_BITS_PER_UINT\&.
.PP
Referenced by ttmath::UInt< value_size >::Div2()\&.
.SS "template<uint value_size> void \fBttmath::UInt\fP< value_size >::SetFromTable (const \fBuint\fP *temp_table, \fBuint\fPtemp_table_len)\fC [inline]\fP"
this method copies the value stored in an another table (warning: first values in temp_table are the highest words -- it's different from our table)
.PP
we copy as many words as it is possible
.PP
if temp_table_len is bigger than value_size we'll try to round the lowest word from table depending on the last not used bit in temp_table (this rounding isn't a perfect rounding -- look at the description below)
.PP
and if temp_table_len is smaller than value_size we'll clear the rest words in the table 
.PP
References ttmath::UInt< value_size >::table, TTMATH_UINT_HIGHEST_BIT, and TTMATH_UINT_MAX_VALUE\&.
.SS "template<uint value_size> void \fBttmath::UInt\fP< value_size >::SetMax ()\fC [inline]\fP"
this method sets the max value which this class can hold (all bits will be one) 
.PP
References ttmath::UInt< value_size >::table, and TTMATH_UINT_MAX_VALUE\&.
.PP
Referenced by ttmath::Int< value_size >::SetMax(), and ttmath::Int< value_size >::SetSignOne()\&.
.SS "template<uint value_size> void \fBttmath::UInt\fP< value_size >::SetMin ()\fC [inline]\fP"
this method sets the min value which this class can hold (for an unsigned integer value the zero is the smallest value) 
.PP
References ttmath::UInt< value_size >::SetZero()\&.
.SS "template<uint value_size> void \fBttmath::UInt\fP< value_size >::SetOne ()\fC [inline]\fP"
this method sets one 
.PP
References ttmath::UInt< value_size >::SetZero(), and ttmath::UInt< value_size >::table\&.
.PP
Referenced by ttmath::Int< value_size >::Pow(), and ttmath::UInt< value_size >::Pow()\&.
.SS "template<uint value_size> void \fBttmath::UInt\fP< value_size >::SetZero ()\fC [inline]\fP"
this method sets zero 
.PP
References ttmath::UInt< value_size >::table\&.
.PP
Referenced by ttmath::Int< value_size >::ChangeSign(), ttmath::UInt< value_size >::ClearFirstBits(), ttmath::UInt< value_size >::Div2(), ttmath::UInt< value_size >::DivInt(), ttmath::UInt< value_size >::Mul1(), ttmath::UInt< value_size >::MulFastestBig(), ttmath::UInt< value_size >::MulInt(), ttmath::Int< value_size >::SetMin(), ttmath::UInt< value_size >::SetMin(), ttmath::UInt< value_size >::SetOne(), and ttmath::UInt< value_size >::Sqrt()\&.
.SS "template<uint value_size> \fBuint\fP \fBttmath::UInt\fP< value_size >::Size () const\fC [inline]\fP"
this method returns the size of the table 
.SS "template<uint value_size> void \fBttmath::UInt\fP< value_size >::Sqrt ()\fC [inline]\fP"
square root e\&.g\&. Sqrt(9) = 3 ('digit-by-digit' algorithm) 
.PP
References ttmath::UInt< value_size >::IsZero(), ttmath::UInt< value_size >::Rcr(), ttmath::UInt< value_size >::SetZero(), and ttmath::UInt< value_size >::table\&.
.SS "template<uint value_size> \fBuint\fP \fBttmath::UInt\fP< value_size >::SubOne ()\fC [inline]\fP"
this method subtracts one from the existing value 
.PP
Referenced by ttmath::Int< value_size >::SubOne()\&.
.SS "template<uint value_size> void \fBttmath::UInt\fP< value_size >::ToString (std::string &result, \fBuint\fPb = \fC10\fP) const\fC [inline]\fP"
this method converts the value to a string with a base equal 'b' 
.SS "template<uint value_size> \fBuint\fP \fBttmath::UInt\fP< value_size >::ToUInt () const\fC [inline]\fP"
this method returns the lowest value from table
.PP
we must be sure when we using this method whether the value will hold in an uint type or not (the rest value from the table must be zero) 
.SH "Friends And Related Function Documentation"
.PP 
.SS "template<uint value_size> std::ostream& operator<< (std::ostream &s, const \fBUInt\fP< value_size > &l)\fC [friend]\fP"
output to standard streams 
.SS "template<uint value_size> std::wostream& operator<< (std::wostream &s, const \fBUInt\fP< value_size > &l)\fC [friend]\fP"
output to standard streams 
.SS "template<uint value_size> std::istream& operator>> (std::istream &s, \fBUInt\fP< value_size > &l)\fC [friend]\fP"
input from standard streams 
.SS "template<uint value_size> std::wistream& operator>> (std::wistream &s, \fBUInt\fP< value_size > &l)\fC [friend]\fP"
input from standard streams 
.SH "Member Data Documentation"
.PP 
.SS "template<uint value_size> \fBuint\fP \fBttmath::UInt\fP< value_size >::table[value_size]"
buffer for the integer value table[0] - the lowest word of the value 
.PP
Referenced by ttmath::UInt< value_size >::BitAnd(), ttmath::UInt< value_size >::BitNot(), ttmath::UInt< value_size >::BitNot2(), ttmath::UInt< value_size >::BitOr(), ttmath::UInt< value_size >::BitXor(), ttmath::UInt< value_size >::ClearFirstBits(), ttmath::UInt< value_size >::CmpBigger(), ttmath::UInt< value_size >::CmpBiggerEqual(), ttmath::UInt< value_size >::CmpEqual(), ttmath::UInt< value_size >::CmpSmaller(), ttmath::UInt< value_size >::CmpSmallerEqual(), ttmath::UInt< value_size >::CompensationToLeft(), ttmath::UInt< value_size >::DivInt(), ttmath::UInt< value_size >::FindLeadingBit(), ttmath::UInt< value_size >::FromUInt(), ttmath::UInt< value_size >::GetBit(), ttmath::UInt< value_size >::Mul1Big(), ttmath::UInt< value_size >::Mul2(), ttmath::UInt< value_size >::Mul2Big(), ttmath::UInt< value_size >::Mul3(), ttmath::UInt< value_size >::Mul3Big(), ttmath::UInt< value_size >::MulFastest(), ttmath::UInt< value_size >::MulFastestBig(), ttmath::UInt< value_size >::MulInt(), ttmath::UInt< value_size >::operator=(), ttmath::UInt< value_size >::Pow(), ttmath::UInt< value_size >::PrintLog(), ttmath::UInt< value_size >::PrintTable(), ttmath::UInt< value_size >::SetBit(), ttmath::UInt< value_size >::SetFromTable(), ttmath::UInt< value_size >::SetMax(), ttmath::UInt< value_size >::SetOne(), ttmath::UInt< value_size >::SetZero(), ttmath::UInt< value_size >::Sqrt(), and ttmath::UInt< value_size >::UInt()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for My Project from the source code\&.
