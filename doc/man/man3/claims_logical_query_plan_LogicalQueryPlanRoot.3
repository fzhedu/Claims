.TH "claims::logical_operator::LogicalQueryPlanRoot" 3 "Fri Oct 9 2015" "My Project" \" -*- nroff -*-
.ad l
.nh
.SH NAME
claims::logical_operator::LogicalQueryPlanRoot \- 
.SH SYNOPSIS
.br
.PP
.PP
Inherits \fBclaims::logical_operator::LogicalOperator\fP\&.
.SS "Public Types"

.in +1c
.ti -1c
.RI "enum \fBOutputStyle\fP { \fBkPrint\fP, \fBkPerformance\fP, \fBkResultCollector\fP }"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBLogicalQueryPlanRoot\fP (NodeID collecter_node_id, \fBLogicalOperator\fP *child, const \fBOutputStyle\fP &fashion=kPerformance, \fBLimitConstraint\fP limit_constraint=\fBLimitConstraint\fP())"
.br
.RI "\fIMethod description: \fP"
.ti -1c
.RI "\fBPlanContext\fP \fBGetPlanContext\fP ()"
.br
.ti -1c
.RI "\fBBlockStreamIteratorBase\fP * \fBGetPhysicalPlan\fP (const unsigned &)"
.br
.RI "\fIMethod description: generate a few physical operators according to this logical operator\&. \fP"
.ti -1c
.RI "bool \fBGetOptimalPhysicalPlan\fP (\fBRequirement\fP requirement, \fBPhysicalPlanDescriptor\fP &physical_plan_descriptor, const unsigned &block_size=4096 *1024)"
.br
.RI "\fIMethod description: NOT USED NOW !!! get the optimal physical plan\&. \fP"
.ti -1c
.RI "void \fBPrint\fP (int level=0) const "
.br
.RI "\fIMethod description: print the limit info and call child to print their logical operator info\&. \fP"
.in -1c
.SS "Additional Inherited Members"
.SH "Member Enumeration Documentation"
.PP 
.SS "enum \fBclaims::logical_operator::LogicalQueryPlanRoot::OutputStyle\fP"
three styles decide which one the top physical operator is: 1) \fBBlockStreamPrint\fP: print result on console directly 2) \fBBlockStreamPerformanceMonitorTop\fP: calculate the real-time performance and print 3) \fBBlockStreamResultCollector\fP : collect result and store it in block buffer, then return to client 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "claims::logical_operator::LogicalQueryPlanRoot::LogicalQueryPlanRoot (NodeIDcollecter_node_id, \fBLogicalOperator\fP *child, const \fBOutputStyle\fP &fashion = \fCkPerformance\fP, \fBLimitConstraint\fPlimit_constraint = \fC\fBLimitConstraint\fP()\fP)"

.PP
Method description: 
.PP
\fBParameters:\fP
.RS 4
\fIcollecter_node_id\fP : specify the id of node that return result to client, which is called master 
.br
\fIchild\fP : the child logical operator of this operator 
.br
\fIfashion\fP : decide the top physical operator (\fBBlockStreamPrint\fP,\fBBlockStreamPerformanceMonitorTop\fP,\fBBlockStreamResultCollector\fP) generated from this logical operator limit_constraint : apply the necessary info about limit, default value is no limit 
.RE
.PP

.SH "Member Function Documentation"
.PP 
.SS "bool claims::logical_operator::LogicalQueryPlanRoot::GetOptimalPhysicalPlan (\fBRequirement\fPrequirement, \fBPhysicalPlanDescriptor\fP &physical_plan_descriptor, const unsigned &block_size = \fC4096 * 1024\fP)\fC [virtual]\fP"

.PP
Method description: NOT USED NOW !!! get the optimal physical plan\&. no requirement
.PP
with requirement 
.PP
Reimplemented from \fBclaims::logical_operator::LogicalOperator\fP\&.
.PP
References claims::logical_operator::PlanContext::GetAggregatedDatasize(), claims::logical_operator::LogicalOperator::GetOptimalPhysicalPlan(), claims::logical_operator::Requirement::requireNetworkTransfer(), and claims::logical_operator::Requirement::tryMerge()\&.
.SS "\fBBlockStreamIteratorBase\fP * claims::logical_operator::LogicalQueryPlanRoot::GetPhysicalPlan (const unsigned &block_size)\fC [virtual]\fP"

.PP
Method description: generate a few physical operators according to this logical operator\&. 
.PP
\fBParameters:\fP
.RS 4
\fIblock_size\fP : give the size of block in physical plan 
.RE
.PP
\fBReturns:\fP
.RS 4
the total physical plan include the physical plan generated by child operator
.RE
.PP
get \fBPlanContext\fP and child physical plan from child , consider \fBPlanContext\fP's partitioner's location and collector, decide whether add expander and exchange operator in physical plan\&.
.PP
choose one of three top physical operators depend on fashion_, return complete physical plan If the number of partitions in the child \fBPlanContext\fP is 1 and the the location is right in the collector, then exchange is not necessary\&.
.PP
Implements \fBclaims::logical_operator::LogicalOperator\fP\&.
.PP
References claims::logical_operator::LogicalOperator::GetPhysicalPlan(), GetPlanContext(), and Config::initial_degree_of_parallelism\&.
.SS "\fBPlanContext\fP claims::logical_operator::LogicalQueryPlanRoot::GetPlanContext ()\fC [virtual]\fP"
get \fBPlanContext\fP from child and return 
.PP
Implements \fBclaims::logical_operator::LogicalOperator\fP\&.
.PP
References claims::logical_operator::LogicalOperator::GetPlanContext()\&.
.PP
Referenced by GetPhysicalPlan()\&.
.SS "void claims::logical_operator::LogicalQueryPlanRoot::Print (intlevel = \fC0\fP) const\fC [virtual]\fP"

.PP
Method description: print the limit info and call child to print their logical operator info\&. 
.PP
\fBParameters:\fP
.RS 4
\fIlevel\fP : specify the level of this operator, the top level is 0\&. so this class's level is always 0\&. level means level*8 space indentation at the begin of line 
.RE
.PP
\fBReturns:\fP
.RS 4
void 
.RE
.PP

.PP
Implements \fBclaims::logical_operator::LogicalOperator\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for My Project from the source code\&.
